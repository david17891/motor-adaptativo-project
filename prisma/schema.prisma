generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// -----------------------------------------------------------------------------
// ENUMS
// -----------------------------------------------------------------------------

enum UserRole {
  SUPER_ADMIN
  PROFESOR
  ALUMNO
}

enum EvaluationStatus {
  DRAFT
  PUBLISHED
  CLOSED
}

// -----------------------------------------------------------------------------
// MODELS
// -----------------------------------------------------------------------------

/// Tenants represent schools or institutions
model Tenant {
  id        String   @id @default(uuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users  User[]
  groups Group[]

  @@map("tenants")
}

/// Global Users, associated with a Tenant (except potentially Super Admins)
model User {
  id           String   @id @default(uuid())
  tenantId     String?
  role         UserRole @default(ALUMNO)
  email        String   @unique
  passwordHash String
  nombre       String
  apellidos    String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenant Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  // As a Professor
  groupsTaught Group[] @relation("ProfessorGroups")
  
  // As a Student
  groupMemberships GroupMember[]
  results          Result[]
  dynamicSessions  DynamicSession[]

  @@map("users")
}

/// Groups within a Tenant, managed by a Professor
model Group {
  id         String   @id @default(uuid())
  tenantId   String
  profesorId String
  name       String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  profesor User   @relation("ProfessorGroups", fields: [profesorId], references: [id], onDelete: Cascade)
  
  members             GroupMember[]
  evaluations         Evaluation[]
  adaptiveEvaluations AdaptiveEvaluation[]

  @@index([tenantId])
  @@index([profesorId])
  @@map("groups")
}

/// Join table for Students and Groups (N:M)
model GroupMember {
  id        String   @id @default(uuid())
  groupId   String
  studentId String
  joinedAt  DateTime @default(now())

  group   Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  student User  @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@unique([groupId, studentId])
  @@map("group_members")
}

/// Global Question Bank
model Question {
  id              String   @id @default(uuid())
  area            String   // e.g., "Matemáticas", "Lectura"
  subarea         String?  // e.g., "Álgebra", "Geometría"
  content         Json     // Rich text, LaTeX, images
  options         Json     // Array of { id, text, is_correct }
  difficultyLevel Int      @default(1)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  examQuestions         ExamQuestion[]
  resultAnswers         ResultAnswer[]
  dynamicSessionAnswers DynamicSessionAnswer[]

  @@map("questions")
}

/// 10 Static Exam Versions
model ExamVersion {
  id          String   @id @default(uuid())
  versionCode String   @unique // e.g., "V1", "V2"
  title       String
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  questions   ExamQuestion[]
  evaluations Evaluation[]

  @@map("exam_versions")
}

/// Join table ExamVersion -> Questions to maintain exact order
model ExamQuestion {
  id            String   @id @default(uuid())
  examVersionId String
  questionId    String
  orderIndex    Int

  examVersion ExamVersion @relation(fields: [examVersionId], references: [id], onDelete: Cascade)
  question    Question    @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([examVersionId, questionId])
  @@unique([examVersionId, orderIndex])
  @@map("exam_questions")
}

/// Assignment of an ExamVersion to a Group
model Evaluation {
  id            String           @id @default(uuid())
  groupId       String
  examVersionId String
  startDate     DateTime
  endDate       DateTime
  status        EvaluationStatus @default(DRAFT)
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  group       Group       @relation(fields: [groupId], references: [id], onDelete: Cascade)
  examVersion ExamVersion @relation(fields: [examVersionId], references: [id], onDelete: Cascade)
  results     Result[]

  @@index([groupId])
  @@map("evaluations")
}

/// A Student's Result for an Evaluation
model Result {
  id           String    @id @default(uuid())
  evaluationId String
  studentId    String
  score        Float?
  startedAt    DateTime  @default(now())
  completedAt  DateTime?

  evaluation Evaluation @relation(fields: [evaluationId], references: [id], onDelete: Cascade)
  student    User       @relation(fields: [studentId], references: [id], onDelete: Cascade)
  
  answers ResultAnswer[]

  @@unique([evaluationId, studentId])
  @@map("results")
}

/// Analytics per question for a Result
model ResultAnswer {
  id               String  @id @default(uuid())
  resultId         String
  questionId       String
  selectedOptionId String? // the ID of the chosen option from the Question's options JSON
  isCorrect        Boolean @default(false)

  result   Result   @relation(fields: [resultId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([resultId, questionId])
  @@map("result_answers")
}

// -----------------------------------------------------------------------------
// ADAPTIVE ENGINE MODELS (FASE 4)
// -----------------------------------------------------------------------------

/// Configuración de una Evaluación Dinámica (Adaptativa) para un Grupo
model AdaptiveEvaluation {
  id              String           @id @default(uuid())
  groupId         String
  title           String
  targetArea      String           // e.g. "Matemáticas"
  targetSubarea   String?          // e.g. "Álgebra" (opcional)
  totalQuestions  Int              @default(10) // Cuántas preguntas hacer antes de terminar
  startDate       DateTime
  endDate         DateTime
  status          EvaluationStatus @default(DRAFT)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  group           Group            @relation(fields: [groupId], references: [id], onDelete: Cascade)
  dynamicSessions DynamicSession[]

  @@index([groupId])
  @@map("adaptive_evaluations")
}

/// Representa el intento (sesión) de un estudiante en una Evaluación Adaptativa
model DynamicSession {
  id                   String             @id @default(uuid())
  adaptiveEvaluationId String
  studentId            String
  estimatedScore       Float?             // Calificación final calculada por el algoritmo
  currentLevel         Int                @default(2) // 1 = Fácil, 2 = Medio, 3 = Difícil. Inicia en Medio.
  status               String             @default("IN_PROGRESS") // IN_PROGRESS, COMPLETED
  startedAt            DateTime           @default(now())
  completedAt          DateTime?

  adaptiveEvaluation AdaptiveEvaluation   @relation(fields: [adaptiveEvaluationId], references: [id], onDelete: Cascade)
  student            User                 @relation(fields: [studentId], references: [id], onDelete: Cascade)
  answers            DynamicSessionAnswer[]

  @@unique([adaptiveEvaluationId, studentId])
  @@index([studentId])
  @@map("dynamic_sessions")
}

/// Historial lineal de las preguntas arrojadas por el Motor a un estudiante
model DynamicSessionAnswer {
  id               String         @id @default(uuid())
  dynamicSessionId String
  questionId       String
  orderIndex       Int            // 1, 2, 3... el orden en que se le presentó
  presentedAt      DateTime       @default(now())
  answeredAt       DateTime?
  selectedOptionId String?        // nulo si se le acabó el tiempo o la saltó
  isCorrect        Boolean        @default(false)
  questionLevel    Int            // El nivel de dificultad que tenía la pregunta cuando se le mostró
  
  dynamicSession   DynamicSession @relation(fields: [dynamicSessionId], references: [id], onDelete: Cascade)
  question         Question       @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([dynamicSessionId, questionId]) // Una sesión no le puede repetir la misma pregunta
  @@unique([dynamicSessionId, orderIndex]) // El índice en la línea de tiempo debe ser único por sesión
  @@map("dynamic_session_answers")
}
